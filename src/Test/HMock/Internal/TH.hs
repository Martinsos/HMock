{-# LANGUAGE CPP #-}
{-# LANGUAGE ExplicitNamespaces #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TupleSections #-}

module Test.HMock.Internal.TH
  ( MockableOptions (..),
    makeMockable,
    makeMockableType,
    makeMockableWithOptions,
    makeMockableTypeWithOptions,
    deriveMockable,
    deriveMockableType,
    deriveMockableWithOptions,
    deriveMockableTypeWithOptions,
    deriveForMockT,
    deriveTypeForMockT,
    deriveForMockTWithOptions,
    deriveTypeForMockTWithOptions,
  )
where

import Control.Monad (replicateM, unless, when, zipWithM)
import Control.Monad.Extra (concatMapM, mapMaybeM)
import Control.Monad.Trans (MonadIO)
import Data.Bool (bool)
import Data.Char (toUpper)
import Data.Default (Default (..))
import Data.Either (partitionEithers)
import qualified Data.Kind
import Data.List (foldl', (\\))
import Data.Maybe (catMaybes)
import Data.Typeable (Typeable)
import GHC.Stack (HasCallStack)
import GHC.TypeLits (Symbol)
import Language.Haskell.TH hiding (Match, match)
import Language.Haskell.TH.Syntax (Lift (lift))
import Test.HMock.Internal.Core
import Test.HMock.Internal.Predicates (Predicate (accept), eq)
import Test.HMock.Internal.TH.Util
import Test.HMock.Internal.Util

-- | Custom options for deriving a 'Mockable' class.
data MockableOptions = MockableOptions
  { -- | Suffix to add to 'Action' and 'Matcher' names.  Defaults to @""@.
    mockSuffix :: String,
    -- | Whether to derive a lax 'MockT' instance.  When a lax instance is
    -- derived, methods that return () may be called at any time without adding
    -- expectations.  If you want only some methods to be lax, or if you want
    -- methods that do not return () to be lax, then you must derive your own
    -- 'MockT' instance, calling either 'mockMethod' or 'mockLaxMethod' as
    -- desired in each case.
    mockLax :: Bool,
    -- | Whether to warn about limitations of the generated mocks.  This is
    -- mostly useful temporarily for finding out why generated code doesn't
    -- match your expectations.  Defaults to @'False'@.
    mockVerbose :: Bool
  }

instance Default MockableOptions where
  def = MockableOptions {mockSuffix = "", mockLax = False, mockVerbose = False}

-- | Define all instances necessary to use HMock with the given class.
-- Equivalent to both 'deriveMockable' and 'deriveForMockT'.
--
-- If @MyClass@ is a class and @myMethod@ is one of its methods, then
-- @'makeMockable' MyClass@ generates all of the following:
--
-- * A @'Mockable' MyClass@ instance.
-- * An associated type @'Action' MyClass@, with a constructor @MyMethod@.
-- * An associated type @'Matcher' MyClass@, with a constructor @MyMethod_@.
-- * An 'Expectable' instance for @'Action' MyClass@ which matches an exact set
--   of arguments, if and only if all of @myMethod@'s arguments have 'Eq' and
--   'Show' instances.
-- * An instance @MyClass ('MockT' m)@ allowing the class to be used in mocks.
makeMockable :: Name -> Q [Dec]
makeMockable = makeMockableType . conT

-- | Define all instances necessary to use HMock with the given constraint type,
-- which should be a class applied to zero or more type arguments.  Equivalent
-- to both 'deriveMockableType' and 'deriveTypeForMockT'.
--
-- See 'makeMockable' for a list of what is generated by this splice.
makeMockableType :: Q Type -> Q [Dec]
makeMockableType = makeMockableTypeWithOptions def

-- | Define all instances necessary to use HMock with the given class.  This is
-- like 'makeMockable', but with the ability to specify custom options.
--
-- See 'makeMockable' for a list of what is generated by this splice.
makeMockableWithOptions :: MockableOptions -> Name -> Q [Dec]
makeMockableWithOptions options = makeMockableTypeWithOptions options . conT

-- | Define all instances necessary to use HMock with the given constraint type,
-- which should be a class applied to zero or more type arguments.  This is
-- like 'makeMockableType', but with the ability to specify custom options.
--
-- See 'makeMockable' for a list of what is generated by this splice.
makeMockableTypeWithOptions :: MockableOptions -> Q Type -> Q [Dec]
makeMockableTypeWithOptions options qt =
  (++) <$> deriveMockableTypeWithOptions options qt
    <*> deriveTypeForMockTWithOptions options qt

-- | Defines the 'Mockable' instance for the given class.
--
-- If @MyClass@ is a class and @myMethod@ is one of its methods, then
-- @'deriveMockable' MyClass@ generates all of the following:
--
-- * A @'Mockable' MyClass@ instance.
-- * An associated type @'Action' MyClass@, with a constructor @MyMethod@.
-- * An associated type @'Matcher' MyClass@, with a constructor @MyMethod_@.
-- * An 'Expectable' instance for @'Action' MyClass@ which matches an exact set
--   of arguments, if and only if all of @myMethod@'s arguments have 'Eq' and
--   'Show' instances.
deriveMockable :: Name -> Q [Dec]
deriveMockable = deriveMockableType . conT

-- | Defines the 'Mockable' instance for the given constraint type, which should
-- be a class applied to zero or more type arguments.  This includes the
-- 'Action' and 'Matcher' types, and its exact 'Matcher's.
--
-- See 'deriveMockable' for a list of what is generated by this splice.
deriveMockableType :: Q Type -> Q [Dec]
deriveMockableType = deriveMockableTypeWithOptions def

-- | Defines the 'Mockable' instance for the given class.  This includes the
-- 'Action' and 'Matcher' types, and its exact 'Matcher's.  This is like
-- 'deriveMockable', but with the ability to specify custom options.
--
-- See 'deriveMockable' for a list of what is generated by this splice.
deriveMockableWithOptions :: MockableOptions -> Name -> Q [Dec]
deriveMockableWithOptions options = deriveMockableTypeWithOptions options . conT

-- | Defines the 'Mockable' instance for the given constraint type, which should
-- be a class applied to zero or more type arguments.  This includes the
-- 'Action' and 'Matcher' types, and its exact 'Matcher's.  This is like
-- 'deriveMockableType', but with the ability to specify custom options.
--
-- See 'deriveMockable' for a list of what is generated by this splice.
deriveMockableTypeWithOptions :: MockableOptions -> Q Type -> Q [Dec]
deriveMockableTypeWithOptions = deriveMockableImpl

-- | Defines an instance of the given class for @'MockT' m@, delegating all of
-- its methods to 'mockMethod' to be handled by HMock.
--
-- This may only be used if all members of the class are mockable methods.  If
-- the class contains some unmockable methods, associated types, or other
-- members, you will need to define this instance yourself, delegating the
-- mockable methods as follows:
--
-- @
-- instance MyClass ('MockT' m) where
--   myMethod x y = 'mockMethod' (MyMethod x y)
--   ...
-- @
deriveForMockT :: Name -> Q [Dec]
deriveForMockT = deriveTypeForMockT . conT

-- | Defines an instance of the given constraint type for @'MockT' m@,
-- delegating all of its methods to 'mockMethod' to be handled by HMock.
-- The type should be a class applied to zero or more type arguments.
--
-- See 'deriveForMockT' for restrictions on the use of this splice.
deriveTypeForMockT :: Q Type -> Q [Dec]
deriveTypeForMockT = deriveTypeForMockTWithOptions def

-- | Defines an instance of the given class for @'MockT' m@, delegating all of
-- its methods to 'mockMethod' to be handled by HMock.  This is like
-- 'deriveForMockT', but with the ability to specify custom options.
--
-- See 'deriveForMockT' for restrictions on the use of this splice.
deriveForMockTWithOptions :: MockableOptions -> Name -> Q [Dec]
deriveForMockTWithOptions options = deriveTypeForMockTWithOptions options . conT

-- | Defines an instance of the given constraint type for @'MockT' m@,
-- delegating all of its methods to 'mockMethod' to be handled by HMock.
-- The type should be a class applied to zero or more type arguments.  This is
-- like 'deriveTypeForMockT', but with the ability to specify custom options.
--
-- See 'deriveForMockT' for restrictions on the use of this splice.
deriveTypeForMockTWithOptions :: MockableOptions -> Q Type -> Q [Dec]
deriveTypeForMockTWithOptions = deriveForMockTImpl

data Instance = Instance
  { instType :: Type,
    instRequiredContext :: Cxt,
    instGeneralParams :: [Name],
    instMonadVar :: Name,
    instMethods :: [Method],
    instExtraMembers :: [Dec]
  }
  deriving (Show)

data Method = Method
  { methodName :: Name,
    methodTyVars :: [Name],
    methodCxt :: Cxt,
    methodArgs :: [Type],
    methodResult :: Type
  }
  deriving (Show)

withClass :: Type -> (Dec -> Q a) -> Q a
withClass t f = do
  case unappliedName t of
    Just cls -> do
      info <- reify cls
      case info of
        ClassI dec@ClassD {} _ -> f dec
        _ -> fail $ "Expected " ++ show cls ++ " to be a class, but it wasn't."
    _ -> fail "Expected a class, but got something else."

getInstance :: MockableOptions -> Type -> Q Instance
getInstance options ty = withClass ty go
  where
    go (ClassD _ className [] _ _) =
      fail $ "Class " ++ nameBase className ++ " has no type parameters."
    go (ClassD cx _ params _ members) = matchVars ty [] (tvName <$> params)
      where
        matchVars :: Type -> [Type] -> [Name] -> Q Instance
        matchVars _ _ [] = internalError
        matchVars (AppT _ _) _ [_] =
          fail $ pprint ty ++ " is applied to too many arguments."
        matchVars (AppT a b) ts (_ : ps) =
          checkExts [FlexibleInstances] >> matchVars a (b : ts) ps
        matchVars _ ts ps = do
          let t = foldl' (\t' v -> AppT t' (VarT v)) ty (init ps)
          let tbl = zip (tvName <$> params) ts
          let cx' = substTypeVars tbl <$> cx
          makeInstance options t cx' tbl (init ps) (last ps) members
    go _ = internalError

makeInstance ::
  MockableOptions ->
  Type ->
  Cxt ->
  [(Name, Type)] ->
  [Name] ->
  Name ->
  [Dec] ->
  Q Instance
makeInstance options ty cx tbl ps m members = do
  processedMembers <- mapM (getMethod ty m tbl) members
  (extraMembers, methods) <-
    partitionEithers <$> zipWithM memberOrMethod members processedMembers
  return $
    Instance
      { instType = ty,
        instRequiredContext = cx,
        instGeneralParams = ps,
        instMonadVar = m,
        instMethods = methods,
        instExtraMembers = extraMembers
      }
  where
    memberOrMethod :: Dec -> Either String Method -> Q (Either Dec Method)
    memberOrMethod dec (Left warning) = do
      when (mockVerbose options) $ reportWarning warning
      return (Left dec)
    memberOrMethod _ (Right method) = return (Right method)

-- | Remove instance context from a method.
--
-- Some GHC versions report class members including the instance context (for
-- example, @show :: Show a => a -> String@, instead of @show :: a -> String@).
-- This looks for the instance context, and substitutes if needed to eliminate
-- it.
localizeMember :: Type -> Name -> Type -> Q Type
localizeMember instTy m t@(ForallT tvs cx ty) = do
  let fullConstraint = AppT instTy (VarT m)
  let unifyLeft (c, cs) = fmap (,cs) <$> unifyTypes c fullConstraint
  results <- mapMaybeM unifyLeft (choices cx)
  case results of
    ((tbl, remainingCx) : _) -> do
      let cx' = substTypeVars tbl <$> remainingCx
          ty' = substTypeVars tbl ty
          (tvs', cx'') =
            relevantContext
              ty'
              ((tvName <$> tvs) \\ (fst <$> tbl), cx')
          t'
            | null tvs' && null cx'' = ty'
            | otherwise = ForallT (bindVar <$> tvs') cx'' ty'
      return t'
    _ -> return t
localizeMember _ _ t = return t

getMethod :: Type -> Name -> [(Name, Type)] -> Dec -> Q (Either String Method)
getMethod instTy m tbl (SigD name ty) = do
  simpleTy <- localizeMember instTy m (substTypeVars tbl ty)
  return $ do
    let (tvs, cx, argsAndReturn) = splitType simpleTy
    (m', result) <- case last argsAndReturn of
      AppT (VarT m') result -> return (m', result)
      _ ->
        Left $
          nameBase name
            ++ " can't be mocked: non-monadic result."
    when (m' /= m) $
      Left $
        nameBase name
          ++ " can't be mocked: return value in wrong monad."
    when (relevantContext result (tvs, cx) /= ([], [])) $
      Left $
        nameBase name
          ++ " can't be mocked: polymorphic return value."
    let argTypes =
          map
            (substTypeVar m (AppT (ConT ''MockT) (VarT m)))
            (init argsAndReturn)
    when (any hasNestedPolyType argTypes) $
      Left $
        nameBase name
          ++ " can't be mocked: rank-n types nested in arguments."
    return $
      Method
        { methodName = name,
          methodTyVars = tvs,
          methodCxt = cx,
          methodArgs = argTypes,
          methodResult = result
        }
getMethod _ _ _ _ = return (Left "A non-value member cannot be mocked.")

isKnownType :: Method -> Type -> Bool
isKnownType method ty = null tyVars && null cx
  where
    (tyVars, cx) =
      relevantContext ty (methodTyVars method, methodCxt method)

withMethodParams :: Instance -> Method -> TypeQ -> TypeQ
withMethodParams inst method t =
  [t|
    $t
      $(pure (instType inst))
      $(litT (strTyLit (nameBase (methodName method))))
      $(varT (instMonadVar inst))
      $(pure (methodResult method))
    |]

deriveMockableImpl :: MockableOptions -> Q Type -> Q [Dec]
deriveMockableImpl options qt = do
  checkExts
    [GADTs, TypeFamilies, DataKinds, FlexibleInstances, MultiParamTypeClasses]

  inst <- getInstance options =<< qt

  when (null (instMethods inst)) $ do
    fail $
      "Cannot derive Mockable because " ++ pprint (instType inst)
        ++ " has no mockable methods."

  (++)
    <$> sequence
      [ instanceD
          (constrainVars [conT ''Typeable] (instGeneralParams inst))
          [t|Mockable $(pure (instType inst))|]
          [ defineActionType options inst,
            defineMatcherType options inst,
            defineShowAction options (instMethods inst),
            defineShowMatcher options (instMethods inst),
            defineMatchAction options (instMethods inst)
          ]
      ]
    <*> defineExpectableActions options inst

defineActionType :: MockableOptions -> Instance -> DecQ
defineActionType options inst = do
  kind <-
    [t|
      Symbol ->
      (Data.Kind.Type -> Data.Kind.Type) ->
      Data.Kind.Type ->
      Data.Kind.Type
      |]
  let cons = actionConstructor options inst <$> instMethods inst
  dataInstD (pure []) ''Action [pure (instType inst)] (Just kind) cons []

actionConstructor :: MockableOptions -> Instance -> Method -> ConQ
actionConstructor options inst method = do
  forallC [] (return (methodCxt method)) $
    gadtC
      [getActionName options method]
      [ return (Bang NoSourceUnpackedness NoSourceStrictness, argTy)
        | argTy <- methodArgs method
      ]
      (withMethodParams inst method [t|Action|])

getActionName :: MockableOptions -> Method -> Name
getActionName options method =
  mkName (map toUpper (take 1 name) ++ drop 1 name ++ mockSuffix options)
  where
    name = nameBase (methodName method)

defineMatcherType :: MockableOptions -> Instance -> Q Dec
defineMatcherType options inst = do
  kind <-
    [t|
      Symbol ->
      (Data.Kind.Type -> Data.Kind.Type) ->
      Data.Kind.Type ->
      Data.Kind.Type
      |]
  let cons = matcherConstructor options inst <$> instMethods inst
  dataInstD (pure []) ''Matcher [pure (instType inst)] (Just kind) cons []

matcherConstructor :: MockableOptions -> Instance -> Method -> ConQ
matcherConstructor options inst method = do
  gadtC
    [getMatcherName options method]
    [ (Bang NoSourceUnpackedness NoSourceStrictness,) <$> mkPredicate argTy
      | argTy <- methodArgs method
    ]
    (withMethodParams inst method [t|Matcher|])
  where
    mkPredicate argTy
      | hasPolyType argTy = do
        checkExts [RankNTypes]
        v <- newName "t"
        forallT [bindVar v] (pure []) [t|Predicate $(varT v)|]
      | null tyVars && null cx = [t|Predicate $(pure argTy)|]
      | otherwise = do
        checkExts [RankNTypes]
        forallT (bindVar <$> tyVars) (pure cx) [t|Predicate $(pure argTy)|]
      where
        (tyVars, cx) =
          relevantContext argTy (methodTyVars method, methodCxt method)

getMatcherName :: MockableOptions -> Method -> Name
getMatcherName options method =
  mkName (map toUpper (take 1 name) ++ drop 1 name ++ mockSuffix options ++ "_")
  where
    name = nameBase (methodName method)

defineShowAction :: MockableOptions -> [Method] -> Q Dec
defineShowAction options methods =
  funD 'showAction (showActionClause options <$> methods)

resolveInstance :: Name -> Type -> Q (Maybe Cxt)
resolveInstance cls t = do
  decs <- reifyInstances cls [t]
  result <- traverse (tryInstance t) decs
  case catMaybes result of
    [cx] -> return (Just (filter (not . null . freeTypeVars) cx))
    _ -> return Nothing
  where
    tryInstance :: Type -> InstanceDec -> Q (Maybe Cxt)
    tryInstance actualTy (InstanceD _ cx (AppT _ genTy) _) =
      unifyTypes genTy actualTy >>= \case
        Just tbl -> return (Just (substTypeVars tbl <$> cx))
        Nothing -> return Nothing
    tryInstance _ _ = return Nothing

showActionClause :: MockableOptions -> Method -> Q Clause
showActionClause options method = do
  argVars <- replicateM (length (methodArgs method)) (newName "a")
  clause
    [ conP
        (getActionName options method)
        (zipWith argPattern (methodArgs method) argVars)
    ]
    ( normalB
        [|
          unwords
            ( $(lift (nameBase (methodName method))) :
              $(listE (zipWith showArg (methodArgs method) argVars))
            )
          |]
    )
    []
  where
    canShow ty
      | not (null (freeTypeVars ty)) = return False
      | otherwise = isInstance ''Show [ty]
    argPattern ty v = canShow ty >>= bool wildP (varP v)
    showArg ty var =
      canShow ty
        >>= bool
          (lift ("(_ :: " ++ pprint (removeModNames ty) ++ ")"))
          [|showsPrec 11 $(varE var) ""|]

defineShowMatcher :: MockableOptions -> [Method] -> Q Dec
defineShowMatcher options methods = do
  clauses <- concatMapM (showMatcherClauses options) methods
  funD 'showMatcher clauses

showMatcherClauses :: MockableOptions -> Method -> Q [ClauseQ]
showMatcherClauses options method = do
  argTVars <- replicateM (length (methodArgs method)) (newName "t")
  predVars <- replicateM (length (methodArgs method)) (newName "p")
  let actionArgs = zipWith actionArg argTVars (methodArgs method)
  let matcherArgs = varP <$> predVars
  let printedArgs = zipWith3 printedArg predVars argTVars (methodArgs method)
  let polyMatcherArgs = zipWith matcherArg predVars (methodArgs method)
  let printedPolyArgs = zipWith printedPolyArg predVars (methodArgs method)
  let body name args = normalB [|unwords ($(lift name) : $(listE args))|]
  return
    [ clause
        [ conP 'Just [conP (getActionName options method) actionArgs],
          conP (getMatcherName options method) matcherArgs
        ]
        (body (nameBase (methodName method)) printedArgs)
        [],
      clause
        [ conP 'Nothing [],
          conP (getMatcherName options method) polyMatcherArgs
        ]
        (body (nameBase (methodName method)) printedPolyArgs)
        []
    ]
  where
    actionArg t ty
      | isKnownType method ty = wildP
      | otherwise = checkExts [ScopedTypeVariables] >> sigP wildP (varT t)

    matcherArg p ty
      | isKnownType method ty = varP p
      | otherwise = wildP

    printedArg p t ty
      | isKnownType method ty = [|"«" ++ show $(varE p) ++ "»"|]
      | otherwise =
        [|"«" ++ show ($(varE p) :: Predicate $(varT t)) ++ "»"|]

    printedPolyArg p ty
      | isKnownType method ty = [|"«" ++ show $(varE p) ++ "»"|]
      | otherwise = [|"«polymorphic»"|]

defineMatchAction :: MockableOptions -> [Method] -> Q Dec
defineMatchAction options methods =
  funD 'matchAction (matchActionClause options <$> methods)

matchActionClause :: MockableOptions -> Method -> Q Clause
matchActionClause options method = do
  argVars <-
    replicateM
      (length (methodArgs method))
      ((,) <$> newName "p" <*> newName "a")
  mmVar <- newName "mismatches"
  clause
    [ conP
        (getMatcherName options method)
        (varP . fst <$> argVars),
      conP (getActionName options method) (varP . snd <$> argVars)
    ]
    ( guardedB
        [ (,) <$> normalG [|$(varE mmVar) == 0|] <*> [|Match|],
          (,) <$> normalG [|otherwise|] <*> [|NoMatch $(varE mmVar)|]
        ]
    )
    [ valD
        (varP mmVar)
        (normalB [|length (filter not $(listE (mkAccept <$> argVars)))|])
        []
    ]
  where
    mkAccept (p, a) = [|accept $(return (VarE p)) $(return (VarE a))|]

defineExpectableActions :: MockableOptions -> Instance -> Q [Dec]
defineExpectableActions options inst =
  concatMapM (defineExpectableAction options inst) (instMethods inst)

defineExpectableAction :: MockableOptions -> Instance -> Method -> Q [Dec]
defineExpectableAction options inst method = do
  maybeCxt <- wholeCxt (methodArgs method)
  argVars <- replicateM (length (methodArgs method)) (newName "a")
  case maybeCxt of
    Just cx -> do
      (: [])
        <$> instanceD
          (pure (methodCxt method ++ cx))
          ( appT
              (withMethodParams inst method [t|Expectable|])
              (withMethodParams inst method [t|Action|])
          )
          [ funD
              'toRule
              [ clause
                  [conP (getActionName options method) (map varP argVars)]
                  ( normalB $
                      let matcherCon = conE (getMatcherName options method)
                       in appE (varE 'toRule) (makeBody argVars matcherCon)
                  )
                  []
              ]
          ]
    _ -> pure []
  where
    makeBody [] e = e
    makeBody (v : vs) e = makeBody vs [|$e (eq $(varE v))|]

    wholeCxt :: [Type] -> Q (Maybe Cxt)
    wholeCxt (ty : ts) = do
      thisCxt <- argCxt ty
      otherCxt <- wholeCxt ts
      return ((++) <$> thisCxt <*> otherCxt)
    wholeCxt [] = return (Just [])

    argCxt :: Type -> Q (Maybe Cxt)
    argCxt argTy
      | not (isKnownType method argTy) = return Nothing
      | VarT v <- argTy =
        Just <$> sequence [[t|Eq $(varT v)|], [t|Show $(varT v)|]]
      | otherwise = do
        eqCxt <- resolveInstance ''Eq argTy
        showCxt <- resolveInstance ''Show argTy
        return ((++) <$> eqCxt <*> showCxt)

deriveForMockTImpl :: MockableOptions -> Q Type -> Q [Dec]
deriveForMockTImpl options qt = do
  inst <- getInstance options =<< qt

  unless (null (instExtraMembers inst)) $
    fail $
      "Cannot derive MockT because " ++ pprint (instType inst)
        ++ " has unmockable methods."

  m <- newName "m"
  let decs = map (mockMethodImpl options) (instMethods inst)

  let cx =
        instRequiredContext inst
          \\ [ AppT (ConT ''Typeable) (VarT (instMonadVar inst)),
               AppT (ConT ''Monad) (VarT (instMonadVar inst)),
               AppT (ConT ''MonadIO) (VarT (instMonadVar inst))
             ]
  let hasMonadInContext = instMonadVar inst `elem` concatMap freeTypeVars cx
  when hasMonadInContext $ checkExts [FlexibleContexts]
  let cxMockT =
        substTypeVar (instMonadVar inst) (AppT (ConT ''MockT) (VarT m)) <$> cx

  (: [])
    <$> instanceD
      ( concat
          <$> sequence
            [ return cxMockT,
              constrainVars [[t|Typeable|]] (instGeneralParams inst),
              constrainVars [[t|Typeable|], [t|MonadIO|]] [m]
            ]
      )
      [t|$(pure (instType inst)) (MockT $(varT m))|]
      decs

mockMethodImpl :: MockableOptions -> Method -> Q Dec
mockMethodImpl options method = do
  argVars <- replicateM (length (methodArgs method)) (newName "a")
  funD
    (methodName method)
    [clause (varP <$> argVars) (normalB (body argVars)) []]
  where
    actionExp [] e = e
    actionExp (v : vs) e = actionExp vs [|$e $(varE v)|]

    body argVars = do
      let defaultResponse = case methodResult method of
            TupleT 0 -> Just [|return ()|]
            _ -> Nothing
      case defaultResponse of
        Just expr
          | mockLax options ->
            [|
              mockLaxMethod
                $expr
                $(actionExp argVars (conE (getActionName options method)))
              |]
          | otherwise ->
            [|
              mockMethodWithDefault
                $expr
                $(actionExp argVars (conE (getActionName options method)))
              |]
        _ ->
          [|
            mockMethod
              $(actionExp argVars (conE (getActionName options method)))
            |]

checkExts :: [Extension] -> Q ()
checkExts = mapM_ checkExt
  where
    checkExt e = do
      enabled <- isExtEnabled e
      unless enabled $
        fail $ "Please enable " ++ show e ++ " to generate this mock."

internalError :: HasCallStack => Q a
internalError = error "Internal error in HMock.  Please report this as a bug."
